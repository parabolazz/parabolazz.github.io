<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-11-13T15:57:30.718Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Mark</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Canvas 学习笔记</title>
    <link href="http://yoursite.com/2018/11/05/Canvas%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/11/05/Canvas 学习笔记/</id>
    <published>2018-11-05T15:53:03.000Z</published>
    <updated>2018-11-13T15:57:30.718Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>在使用 canvas 之前，需要使用 getContext 获取上下文。<br>在 js 里获取了 canvas 元素以后，我们可以用下面的方法取到 canvas 的上下文，这是 canvas 一切操作的基础。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</div><div class="line"><span class="comment">// 第一个参数可以是 2d/webgl/webg2，后两者代表的是 3 维上下文</span></div></pre></td></tr></table></figure></p><p>获取了 canvas 上下文，我们就可以进行下面的各种神奇操作啦~</p><h2 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h2><p>路径是画图的基础，当你要开始画一个图形的时候，首先你需要开启一条路径。当一个图形完成的时候，你需要闭合这个路径。PS：</p><ol><li>当你画矩形（fillRect/strokeRect）的时候，不需要手动开启路径。</li><li>当你使用 fill 方法的时候，不需要手动闭合这个路径，因为 fill 会自动帮你闭合。</li></ol><h3 id="开始路径-beginPath"><a href="#开始路径-beginPath" class="headerlink" title="开始路径 beginPath"></a>开始路径 beginPath</h3><p>beginPath 顾名思义，是用来开启一个路径的。<br>但是它却是一个挺让人迷糊的功能，刚开始接触它的时候可能会认为有的时候不写 beginPath，代码也 work。这里的原因就在于：<strong>当你使用 fillRect/strokeRect 这种独立画出区域的函数，是不受 beginPath 影响的。</strong></p><p>moveTo()、lineTo()、fill()、stroke()、quadricCurveTo()、bezierCurveTo()、arcTo() 以及 arc() 等等都会受到 beginPath 的影响。比如：fill/stroke 都会以“上一次beginPath”之后的所有路径为基础进行绘制。</p><h3 id="闭合路径-closePath"><a href="#闭合路径-closePath" class="headerlink" title="闭合路径 closePath"></a>闭合路径 closePath</h3><p>closePath 虽然名字看起来像是用来结束一个路径的，但实际上它却<strong>只是用来闭合路径</strong>的。但我们使用 stroke （线条）来描绘图形时，由于他它不像 fill 那样会自动闭合，所以如果想得到一个封闭的图形，就需要使用 closePath 来手动闭合。<a href="https://www.cnblogs.com/xuehaoyue/p/6549682.html" target="_blank" rel="external">参考这里</a></p><h2 id="画图基础"><a href="#画图基础" class="headerlink" title="画图基础"></a>画图基础</h2><p>在进行真正的画图之前，我们需要知道一些画图的基础，比如移动画笔、填充颜色。</p><h3 id="moveTo-x-y"><a href="#moveTo-x-y" class="headerlink" title="moveTo(x,y)"></a>moveTo(x,y)</h3><p>将画笔移动到 (x, y) 点的位置，用于画不连续图形的时候改变画笔位置</p><h3 id="fill-stroke-和-fillStyle-strokeStyle-color"><a href="#fill-stroke-和-fillStyle-strokeStyle-color" class="headerlink" title="fill/stroke() 和 fillStyle/strokeStyle(color)"></a>fill/stroke() 和 fillStyle/strokeStyle(<em>color</em>)</h3><p>这两个方法很像，fill 用于填充整个画出来的图形，并隐式闭合路径。storke 用于线条描绘画出来的图形，但不闭合路径，所以 <strong>storke 需要与 closePath 结合来闭合路径</strong><br>它们都有自己配置颜色的方法：<code>fillStyle/strokeStyle</code></p><h2 id="画图方法"><a href="#画图方法" class="headerlink" title="画图方法"></a>画图方法</h2><p>在 canvas 里面，我们可以直接画出矩形、圆形、线条和文字。</p><ul><li>fillRect/strokeRect(x, y, w, h) 以 x,y<br>为左上角画出宽为 w, 高为 h 的矩形</li><li>arc(x, y, radius, startAngle, endAngle, direction)<br>以 x,y 为圆心， radius 为半径， direction 为方向，从 sAngle 到 eAngle 画出一段弧线。当 eAngle 为 <strong>Math.PI*2</strong> 时，它就是一个圆形。</li><li>lineTo(x,y)<br>从当前位置画出一条到 x, y 点的线条</li><li>fillText/strokeText(text, x, y) 绘制文字</li></ul><p>拥有了以上了基础，我们便可以画出一些较为基础的 canvas 图形了~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;开始&quot;&gt;&lt;a href=&quot;#开始&quot; class=&quot;headerlink&quot; title=&quot;开始&quot;&gt;&lt;/a&gt;开始&lt;/h2&gt;&lt;p&gt;在使用 canvas 之前，需要使用 getContext 获取上下文。&lt;br&gt;在 js 里获取了 canvas 元素以后，我们可以用下面的
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Vue 模板编译</title>
    <link href="http://yoursite.com/2018/01/20/Vue%20%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91/"/>
    <id>http://yoursite.com/2018/01/20/Vue 模板编译/</id>
    <published>2018-01-20T06:47:39.000Z</published>
    <updated>2018-01-20T15:23:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>Vue 的 template 是如何编译成真正的 HTML 并做到双向绑定等等特殊功能的呢？以往这个问题对我来说一直是个黑洞。最近看了 Vue 的源码，对模板编译的整个过程的脉络有了更为清晰的了解。</p><h2 id="先甩一张图"><a href="#先甩一张图" class="headerlink" title="先甩一张图"></a>先甩一张图</h2><p><img src="http://wx4.sinaimg.cn/mw690/7cd9fb9fgy1fnn2xe4gklj20xv113jz2.jpg" alt="Vue 渲染过程"><br>在这张图中，我们可以看到 Vue 的模板编译是在 $mount 的过程中进行的，在 $mount 的时候执行了 compile 这个方法来将 template 里的内容转换成真正的 HTML 代码。complie 之后执行的事情也蛮重要的，这个我们留到最后再说。complie 最终生成 render 函数，等待调用。这个方法分为三步：</p><ul><li>parse 函数解析 template</li><li>optimize 函数优化静态内容</li><li>generate 函数创建 render 函数字符串</li></ul><h2 id="parse-解析"><a href="#parse-解析" class="headerlink" title="parse 解析"></a>parse 解析</h2><p>在了解 parse 的过程之前，我们需要了解 AST，AST 的全称是 Abstract Syntax Tree，也就是所谓抽象语法树，用来表示代码的数据结构。在 Vue 中我把它理解为<strong>嵌套的、携带标签名、属性和父子关系的 JS 对象，以树来表现 DOM 结构。</strong><br>下面是 Vue 里的 AST 的定义：</p><p><img src="http://wx3.sinaimg.cn/mw690/7cd9fb9fgy1fnn3iq86flj20i40nngps.jpg" alt="AST"></p><p>我们可以看到 AST 有三种类型，并且通过 children 这个字段层层嵌套形成了树状的结构。而每一个 AST 节点存放的就是我们的 HTML 元素、插值表达式或文本内容。AST 正是 parse 函数生成和返回的。<br>parse 函数里定义了许多的正则表达式，通过对标签名开头、标签名结尾、属性字段、文本内容等等的递归匹配。把字符串类型的 template 转化成了树状结构的 AST。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// parse 里定义的一些正则</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> onRE = <span class="regexp">/^@|^v-on:/</span> <span class="comment">//匹配 v-on</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> dirRE = <span class="regexp">/^v-|^@|^:/</span> <span class="comment">//匹配 v-on 和 v-bind</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> forAliasRE = <span class="regexp">/(.*?)\s+(?:in|of)\s+(.*)/</span> <span class="comment">//匹配 v-for 属性</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> forIteratorRE = <span class="regexp">/\((\&#123;[^&#125;]*\&#125;|[^,]*),([^,]*)(?:,([^,]*))?\)/</span> <span class="comment">//匹配 v-for 的多种形式</span></div></pre></td></tr></table></figure><p>我们可以把这个过程理解为一个截取的过程，它把 template 字符串里的元素、属性和文本一个个地截取出来，其中的细节十分琐碎，涉及到各种不同情况（比如不同类型的 v-for，各种 vue 指令、空白节点以及父子关系等等），我们不再赘述。</p><p><img src="http://wx3.sinaimg.cn/mw690/7cd9fb9fgy1fnn42mbfiwj20u60diwho.jpg" alt="Parse 过程"></p><p>假设我们有一个元素<code>&lt;div id=&quot;test&quot;&gt;texttext&lt;/div&gt;</code>，在 parse 完之后会变成如下的结构并返回：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">ele1 = &#123;</div><div class="line">  type: <span class="number">1</span>,</div><div class="line">  tag: <span class="string">"div"</span>,</div><div class="line">  attrsList: [&#123;<span class="attr">name</span>: <span class="string">"id"</span>, <span class="attr">value</span>: <span class="string">"test"</span>&#125;],</div><div class="line">  attrsMap: &#123;<span class="attr">id</span>: <span class="string">"test"</span>&#125;,</div><div class="line">  parent: <span class="literal">undefined</span>,</div><div class="line">  children: [&#123;</div><div class="line">      type: <span class="number">3</span>,</div><div class="line">      text: <span class="string">'texttext'</span></div><div class="line">    &#125;</div><div class="line">  ],</div><div class="line">  plain: <span class="literal">true</span>,</div><div class="line">  attrs: [&#123;<span class="attr">name</span>: <span class="string">"id"</span>, <span class="attr">value</span>: <span class="string">"'test'"</span>&#125;]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="optimize-优化"><a href="#optimize-优化" class="headerlink" title="optimize 优化"></a>optimize 优化</h2><p>在第二步中，会对 parse 生成的 AST 进行静态内容的优化。静态内容指的是<strong>和数据没有关系，不需要每次都刷新的内容。</strong>标记静态节点的作用是为了在后面做 Vnode 的 diff 时起作用，用来确认一个节点是否应该做 patch 还是直接跳过。optimize 的过程分为两步：</p><ul><li>标记所有的静态和非静态结点</li><li>标记静态根节点</li></ul><h3 id="标记所有的静态和非静态结点"><a href="#标记所有的静态和非静态结点" class="headerlink" title="标记所有的静态和非静态结点"></a>标记所有的静态和非静态结点</h3><p>关于这一段我们可以直接看源码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">markStatic</span> (<span class="params">node: ASTNode</span>) </span>&#123;</div><div class="line">  <span class="comment">// 标记 static 属性</span></div><div class="line">  node.static = isStatic(node)</div><div class="line">  <span class="keyword">if</span> (node.type === <span class="number">1</span>) &#123;</div><div class="line">    <span class="comment">// 注意这个判断逻辑</span></div><div class="line">    <span class="keyword">if</span> (</div><div class="line">      !isPlatformReservedTag(node.tag) &amp;&amp;</div><div class="line">      node.tag !== <span class="string">'slot'</span> &amp;&amp;</div><div class="line">      node.attrsMap[<span class="string">'inline-template'</span>] == <span class="literal">null</span></div><div class="line">    ) &#123;</div><div class="line">      <span class="keyword">return</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = node.children.length; i &lt; l; i++) &#123;</div><div class="line">      <span class="keyword">const</span> child = node.children[i]</div><div class="line">      markStatic(child)</div><div class="line">      <span class="keyword">if</span> (!child.static) &#123;</div><div class="line">        node.static = <span class="literal">false</span></div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>上面的代码中有几个需要注意的地方：</p><ul><li>isStatic 函数<br>isStatic 函数顾名思义是判断该节点是否 static 的函数，符合如下内容的节点就会被认为是 static 的节点：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="number">1.</span> 如果是表达式AST节点，直接返回 <span class="literal">false</span></div><div class="line"><span class="number">2.</span> 如果是文本AST节点，直接返回 <span class="literal">true</span></div><div class="line"><span class="number">3.</span> 如果元素是元素节点，阶段有 v-pre 指令 ||</div><div class="line">  <span class="number">1.</span> 没有任何指令、数据绑定、事件绑定等 &amp;&amp;</div><div class="line">  <span class="number">2.</span> 没有 v-<span class="keyword">if</span> 和 v-<span class="keyword">for</span> &amp;&amp;</div><div class="line">  <span class="number">3.</span> 不是 slot 和 component &amp;&amp;</div><div class="line">  <span class="number">4.</span> 是 HTML 保留标签 &amp;&amp;</div><div class="line">  <span class="number">5.</span> 不是 template 标签的直接子元素并且没有包含在 <span class="keyword">for</span> 循环中</div><div class="line">  则返回 <span class="literal">true</span></div></pre></td></tr></table></figure><ul><li>if 判断条件</li></ul><ol><li>!isPlatformReservedTag(node.tag)：node.tag 不是 HTML 保留标签时返回true。</li><li>node.tag !== ‘slot’：标签不是slot。</li><li>node.attrsMap[‘inline-template’] == null：node不是一个内联模板容器。</li></ol><p>如果满足上面的所有条件，那么这个节点的 static 就会被置为 false 并且不递归子元素，当不满足上面某一个条件时，递归子元素判断子元素是否 static，只有所有元素都是 static 的时候，该元素才是 static。</p><h3 id="标记静态根节点"><a href="#标记静态根节点" class="headerlink" title="标记静态根节点"></a>标记静态根节点</h3><p>这部分理解起来很简单，只有当一个节点是 static 并且其不能只拥有一个静态文本节点时才能被称为 static root。因为作者认为这种情况去做优化，其消耗会超过获得的收益。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (node.static &amp;&amp; node.children.length &amp;&amp; !(</div><div class="line">  node.children.length === <span class="number">1</span> &amp;&amp;</div><div class="line">  node.children[<span class="number">0</span>].type === <span class="number">3</span></div><div class="line">)) &#123;</div><div class="line">  node.staticRoot = <span class="literal">true</span></div><div class="line">  <span class="keyword">return</span></div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  node.staticRoot = <span class="literal">false</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="generate-生成-render"><a href="#generate-生成-render" class="headerlink" title="generate 生成 render"></a>generate 生成 render</h2><p>生成 render 的 generate 函数的输入也是 AST，它递归了 AST 树，为不同的 AST 节点创建了不同的内部调用方法，等待后面的调用。生成 render 函数的过程如下：<br><img src="http://wx1.sinaimg.cn/mw690/7cd9fb9fgy1fnn5x3x8ltj216k09u76c.jpg" alt="generate 函数"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">几种内部方法</div><div class="line">_c：对应的是 createElement 方法，顾名思义，它的含义是创建一个元素(Vnode)</div><div class="line">_v：创建一个文本结点。</div><div class="line">_s：把一个值转换为字符串。（eg: &#123;&#123;data&#125;&#125;）</div><div class="line">_m：渲染静态内容</div></pre></td></tr></table></figure></p><p>假设我们有这么一段 template<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;template&gt;</div><div class="line">  &lt;div id=&quot;test&quot;&gt;</div><div class="line">    &#123;&#123;val&#125;&#125;</div><div class="line">    &lt;img src=&quot;http://xx.jpg&quot;&gt;</div><div class="line">  &lt;/div&gt;</div><div class="line">&lt;/template&gt;</div></pre></td></tr></table></figure></p><p>最终会被转换成这样子的函数字符串<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;<span class="attr">render</span>: <span class="string">"with(this)&#123;return _c('div',&#123;attrs:&#123;"</span>id<span class="string">":"</span>test<span class="string">"&#125;&#125;,[[_v(_s(val))]),_v("</span> <span class="string">"),_m(0)])&#125;"</span>&#125;</div></pre></td></tr></table></figure></p><h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>整个 Vue 渲染过程，前面我们说了 complie 的过程，在做完 parse、optimize 和 generate 之后，我们得到了一个 render 函数字符串。<br>那么接下来 Vue 做的事情就是 new watcher，这个时候会对绑定的数据执行监听，render 函数就是数据监听的回调所调用的，其结果便是重新生成 vnode。当这个 render 函数字符串在第一次 mount、或者绑定的数据更新的时候，都会被调用，生成 Vnode。如果是数据的更新，那么 Vnode 会与数据改变之前的 Vnode 做 diff，对内容做改动之后，就会更新到我们真正的 DOM 上啦~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Vue 的 template 是如何编译成真正的 HTML 并做到双向绑定等等特殊功能的呢？以往这个问题对我来说一直是个黑洞。最近看了 Vue 的源码，对模板编译的整个过程的脉络有了更为清晰的了解。&lt;/p&gt;
&lt;h2 id=&quot;先甩一张图&quot;&gt;&lt;a href=&quot;#先甩一张图&quot; c
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>I&#39;m back</title>
    <link href="http://yoursite.com/2017/12/10/I&#39;m%20back/"/>
    <id>http://yoursite.com/2017/12/10/I&#39;m back/</id>
    <published>2017-12-10T14:37:39.000Z</published>
    <updated>2017-12-10T14:50:57.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="我回来了"><a href="#我回来了" class="headerlink" title="我回来了"></a>我回来了</h1><p>看了一下上一次写文章的时间 已经是一年零6个月以前了<br>中间发生了很多事 我找到实习了 我毕业 开始工作了 我又迷茫了一段时间 我看了好几场音乐会 虽然依然单身<br>所幸的是 我没被抛弃<br>学了一段时间的 Vue 源码 有了一点点收获<br>但对待生活的态度才是我生命中最大的阻碍 需要我去突破<br>好好学习 好好生活</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;我回来了&quot;&gt;&lt;a href=&quot;#我回来了&quot; class=&quot;headerlink&quot; title=&quot;我回来了&quot;&gt;&lt;/a&gt;我回来了&lt;/h1&gt;&lt;p&gt;看了一下上一次写文章的时间 已经是一年零6个月以前了&lt;br&gt;中间发生了很多事 我找到实习了 我毕业 开始工作了 我又迷茫了一
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>从闭包谈回闭包</title>
    <link href="http://yoursite.com/2016/05/27/%E4%BB%8E%E9%97%AD%E5%8C%85%E8%B0%88%E5%9B%9E%E9%97%AD%E5%8C%85/"/>
    <id>http://yoursite.com/2016/05/27/从闭包谈回闭包/</id>
    <published>2016-05-27T14:48:17.000Z</published>
    <updated>2017-09-29T14:54:43.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="从一个闭包问题谈起"><a href="#从一个闭包问题谈起" class="headerlink" title="从一个闭包问题谈起"></a>从一个闭包问题谈起</h2><p>接触闭包到现在也有一段时间了。虽然不能说不知道闭包是什么，但也只是懂得高程上说的“闭包是指有权访问另一个函数作用域里的变量的函数，创建闭包的常见方式是在一个函数里创建另一个函数。”，知道闭包能访问父函数里的变量。（后来发现这样说是错误的。）但是，心里一直有一个疑问，到底闭包是怎么访问到“父级函数”里的变量的？不找不知道，一找吓一跳。<br>没想到，这背后的缘由还真不简单啊。接下来我就把我所理解的原因一一讲解出来。</p><p>首先给出结论：<br>闭包之所以能够访问外部函数的变量，是因为其调用时的作用域链，不仅包含了自己的活动对象（变量对象），还包含了外部函数的变量对象。变量对象与作用域链都是执行上下文的一个属性，与执行上下文紧密相关。</p><p>这里面涉及到三个概念：执行上下文，变量对象和作用域链。我们来好好捋一捋：</p><h3 id="执行上下文-Execution-Context"><a href="#执行上下文-Execution-Context" class="headerlink" title="执行上下文( Execution Context )"></a>执行上下文( Execution Context )</h3><p>执行上下文，也叫执行环境，分为全局，函数和 eval （这里暂且不谈）三类。</p><p>全局的执行上下文在js载入的时候就已经产生，退出程序后才销毁。<br>每当一个函数被调用，就产生了一个它的执行上下文。这个执行上下文是一个类似于栈的结构，栈顶是当前活动的执行上下文，栈底是全局的执行上下文，而中间就是外部函数的执行上下文（可能有多个，由作用域链一层层往上，直至全局）。每当调用一个函数，该函数的执行上下文就被推到栈的前端，在执行完毕后，栈将其环境弹出，环境被销毁，该环境里的函数和变量定义也被销毁。<br>当JS代码被浏览器载入后，默认进入全局的执行上下文，而当在全局执行上下文调用一个函数时，引擎就为该函数创建一个执行上下文，并将其压入执行上下文栈的顶端。浏览器执行的总是位于顶端的执行上下文，当其被执行完毕，就会从栈的顶部被弹出。然后浏览器就会回到它之前的执行下上文去执行代码。</p><h3 id="变量对象-Variable-Object"><a href="#变量对象-Variable-Object" class="headerlink" title="变量对象( Variable Object )"></a>变量对象( Variable Object )</h3><p>前文已经说到，执行上下文在调用时被建立，那么执行上下文是如何建立的呢？这里就不<br>得不谈到变量对象了。函数执行上下文的创建分为两个阶段：</p><ul><li>进入执行环境阶段（已进入其执行环境，但环境内代码未执行）<br>在这个阶段：浏览器做了三件事：<br>建立变量，函数，arguments对象，参数，（但未对变量赋值，包括函数表达式）保存在变量对象中。变量对象被添加到 [[scope]] 前端，在作用域链中位于第一位。<br>建立作用域链<br>确定 this 的值<br>在这个时候，函数的执行上下文对应的变量对象，先后包括：</li></ul><table><thead><tr><th>保存的变量</th><th>保存的形式</th><th>备注</th></tr></thead><tbody><tr><td>函数形参</td><td>形参名：对应值</td><td></td></tr><tr><td>函数声明</td><td>函数名：函数体</td><td>函数声明提升，如果存在同名，即形参里有同名，则覆盖形参</td></tr><tr><td>变量声明</td><td>变量名：undefined</td><td>变量声明提升，如果存在同名，即形参或函数有同名，则被忽略</td></tr></tbody></table><ul><li>代码执行阶段<br>变量赋值，函数引用和执行其他代码<br>当这两个阶段都完成，函数的执行上下文也就被创建。<br>那么全局的执行上下文呢？前文说过，全局的执行上下文在加载JS代码时就已经创建，这时候，全局的变量对象也被创建，里面包含：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">global = &#123;</div><div class="line">  Math: </div><div class="line">  String: </div><div class="line">  ...</div><div class="line">  ...</div><div class="line">  window: global</div><div class="line">&#125;;</div><div class="line">Math, String, Date等等属性被初始化，这也是我们在全局代码里的所有地方都能使用它们的根本原因。</div><div class="line"></div><div class="line">看到这里，是不是有点累了？文字再多，不如一段代码小试牛刀：</div><div class="line">如果这段代码你能理解，”变量对象”也就了然于胸啦。</div><div class="line"></div><div class="line">console.log(x); //function x()&#123;&#125;, 函数声明提升至VO里</div><div class="line"></div><div class="line">var x = 10; // 命名冲突，x被忽略</div><div class="line">console.log(x); //执行阶段赋值，此时 x = 10</div><div class="line">x = 20; //执行阶段赋值，此时 x = 20</div><div class="line"></div><div class="line">function x()&#123;&#125;; //执行阶段忽略</div><div class="line">console.log(x); // x = 20</div><div class="line"></div><div class="line">if (true) &#123;</div><div class="line">    var a = 1;  //变量声明，VO里保存为undefined</div><div class="line">&#125;else &#123; </div><div class="line">    var b = 2;  //变量声明，VO里保存为undefined</div><div class="line">&#125;  </div><div class="line"></div><div class="line">console.log(a); //执行阶段赋值， a = 1</div><div class="line">console.log(b); //依然为undefined</div></pre></td></tr></table></figure></li></ul><h3 id="作用域链-Scope"><a href="#作用域链-Scope" class="headerlink" title="作用域链( Scope )"></a>作用域链( Scope )</h3><p>这里先摘抄高程闭包章节里的一段话：</p><p>在创建函数时，会创建一个预先包含全局变量对象的作用域链，这个作用域链被保存在函数内部的 [[scope]] 属性中。当调用函数时，会为函数创建一个执行上下文，然后通过复制函数的 [[scope]] 属性中的对象构建起执行上下文的作用域链。此后，又有一个活动对象（在此作变量对象使用）被创建并推入执行上下文作用域链的前端。此时，其作用域链包含两个变量对象：本地活动对象和全局变量对象。</p><p>这里指的是在全局环境创建、调用函数的情况，如果在函数内部再创建、调用函数呢？<br>那么这段话就应该这么改：</p><p>在创建函数时，会创建一个预先包含外部函数变量对象和全局变量对象的作用域链，这个作用域链被保存在函数内部的 [[scope]] 属性中。当调用函数时，会为函数创建一个执行上下文，然后通过复制函数的 [[scope]] 属性中的对象构建起执行上下文的作用域链。此后，又有一个活动对象（在此作变量对象使用）被创建并推入执行上下文作用域链的前端。此时，其作用域链包含的变量对象：本地活动对象（栈顶）、外部函数变量对象和全局变量对象（栈底）</p><p>如果，在函数内部的函数里，再创建、调用函数呢？<br>我猜你也已经想到了答案，那么，作用域链的作用 （好绕） 你也应该清楚了。</p><p>作用域链是内部函数环境所有变量对象的列表，它的本质是一个指向变量对象的指针列表，它只引用但不实际包含变量对象。内部函数根据作用域链所保存的外部函数变量对象，来访问外部函数的变量！</p><p>由一个闭包问题结束</p><p>看到这里，三大巨头的介绍就已经完毕了。再回过头看结论，也大概能清楚了。那么这时候，让我们回到一个经典的闭包问题，这个问题不仅高程里提到过，网络上各种提问也是层出不穷，且看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//我要隔一秒输出一个i的值</div><div class="line">for (var i = 1; i &lt;= 5; i++) &#123;</div><div class="line">    setTimeout( function()&#123;</div><div class="line">        console.log( i );</div><div class="line">    &#125;, i*1000 );</div><div class="line">&#125;</div><div class="line">//然而现实却是：每隔1秒输出1个6</div></pre></td></tr></table></figure><p>为什么都是6？因为JavaScript是单线程执行的，只有循环结束以后，setTimeout 中指定的函数才会被异步执行。所以，在上面的代码中，5次循环，将会有5个函数被异步执行，然而这5个函数全部指向同一个 i 变量，它们在本地活动对象里找不到 i，就通过作用域链往上找，在外部函数（也就是全局）变量对象找到了 i，但此时循环已结束，i 的值已经是6了。<br>这里提供一种解决办法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">for (var i = 1; i &lt;= 5; i++) &#123;</div><div class="line">    (function(arg)&#123;</div><div class="line">        setTimeout(function()&#123;</div><div class="line">            console.log(arg);</div><div class="line">        &#125;, arg*1000 );</div><div class="line">    &#125;)(i)；</div><div class="line">&#125;// 1 2 3 4 5</div></pre></td></tr></table></figure><p>通过声明一个立即调用函数，将 i 作为实参传进setTimeout，这时立即调用函数的变量对象里多了一个arg，它的值为 i，因为参数是按值传递的，所以每个 setTimeout 里的匿名函数可通过作用域链访问到每个 arg 的值，也就是 i。</p><p>绕了一圈，我们又讲回到了闭包，但这次是不是豁然开朗得多了呢？<br>然而，关于闭包，还有许多更深入的内容，比如函数的 [[scope]] 和执行上下文的 scope 之间的异同；比如作用域的细分。这些都过于繁杂，出于我的能力以及本文篇幅的限制，在此就不展开了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;从一个闭包问题谈起&quot;&gt;&lt;a href=&quot;#从一个闭包问题谈起&quot; class=&quot;headerlink&quot; title=&quot;从一个闭包问题谈起&quot;&gt;&lt;/a&gt;从一个闭包问题谈起&lt;/h2&gt;&lt;p&gt;接触闭包到现在也有一段时间了。虽然不能说不知道闭包是什么，但也只是懂得高程上说的“闭
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JS 动画学习笔记</title>
    <link href="http://yoursite.com/2016/05/19/JS-%E5%8A%A8%E7%94%BB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2016/05/19/JS-动画学习笔记/</id>
    <published>2016-05-19T14:41:10.000Z</published>
    <updated>2017-09-29T14:44:44.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="巩固的知识点"><a href="#巩固的知识点" class="headerlink" title="巩固的知识点"></a>巩固的知识点</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Math.ceil(3.4); //4</div><div class="line">Math.floor(3.4); //3</div><div class="line">Math.round(3.4); //3</div><div class="line">Math.round(0.34); //0</div><div class="line">//都是返回整数</div><div class="line"></div><div class="line">window.getComputedStyle(obj,false)[attr];</div><div class="line">//getComputedStyle函数，用于获取所有样式下的样式属性，参数1是元素，参数2是伪类</div></pre></td></tr></table></figure><p>在整个框架的学习中，一开始其实是懵逼的：本以为只是通过这个课程学习JS的动画，没想到一步一步的改造和封装，一步一步将变量浓缩成形参，伪JSON（其实是对象）的初次接触、让left值、宽度、高度甚至透明度都可以在多组的、同时的变化下用同一套函数，最后达到了一个适用性挺高的运动框架！这对于初次接触函数封装、伪JSON使用的我来说，无疑是既具有挑战性却也充满 “哇！” 点的惊奇的。</p><h2 id="JS动画的要点"><a href="#JS动画的要点" class="headerlink" title="JS动画的要点"></a>JS动画的要点</h2><p>定时器的设置</p><p>这一点相信大家都有共识，通过setInterval()函数让浏览器在很短的间隔时间里做出一点改变（比如位移），再通过不断地调用，来达到目标条件（用if判断），再停止定时器。但这里有一个要点：当为一组元素添加事件动画时，需要遍历为元素添加属性，在运动函数里首先清除定时器的时候需要清除对应元素的定时器属性，也就是下面的obj.timer，而不是直接清除timer。否则组里元素的定时器清除器是共用的，将会相互干扰。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">for (var i = 0; i &lt; li.length; i++) &#123;</div><div class="line">    li[i].timer = null; //为每个元素添加独立的timer属性，用于控制独立的定时器</div><div class="line">    li[i].onmouseover = function()&#123;</div><div class="line">        startmove(this);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function startmove(obj)&#123; </div><div class="line">    //清除定时器，防止多个定时器同时运行，注意这里的obj.timer</div><div class="line">    clearInterval(obj.timer);</div><div class="line">    obj.timer = setInterval(function()&#123;</div><div class="line">    //code here</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="从匀速运动变成缓冲运动"><a href="#从匀速运动变成缓冲运动" class="headerlink" title="从匀速运动变成缓冲运动"></a>从匀速运动变成缓冲运动</h2><p>有了动画，要如何做的逼真一点呢？这里可以从动画速度这个切入点入手：当元素的改变越来越接近目标值时，改变的速度也越来越小，也就是说速度随着目标值的改变而改变，就如火车进站的减速效果，这样的缓冲效果会让动画显得更加逼真。<br>以left值改变为例，匀速运动的速度:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">timer = setInterval(function(target)&#123;</div><div class="line">    var speed = 0;</div><div class="line">    if(div.offsetLeft &gt; target)&#123;</div><div class="line">        speed = -10;//left值要变小，速度要为负值</div><div class="line">    &#125;else&#123;</div><div class="line">        speed = 10;//left值变大，速度为正</div><div class="line">    &#125;</div><div class="line">    if (div.offsetLeft == target) &#123;</div><div class="line">        clearInterval(timer);</div><div class="line">    &#125;else&#123;</div><div class="line">        div.style.left = div.offsetLeft + speed + &quot;px&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;,30);</div></pre></td></tr></table></figure><p>将它改为缓冲运动，我们需要做两件事：</p><p>改变固定的速度值，将速度和目标值联系在一起<br><code>var speed = (target - div.offsetLeft)/8</code><br>用目标值减去当前left值，再除以一个系数（否则第一次运行speed就等于整个动画的路程，就没有动画效果）</p><p>将速度值取整</p><p><code>speed = speed &gt; 0 ? Math.ceil(speed):Math.floor(speed);</code><br>如果向左-&gt;速度正值-&gt;向上取整，否则向下取整<br>运动运行到后期时，因为除法的存在，speed会出现小数如0.75， 如果这时div移动到了190，那么这时left值也会出现小数如190.75, 浏览器默认将小数去掉，宽度为190,下次执行speed还是0.75,造成了死循环，div将一直停留在190，到达不了target，定时器却会一直运行。所以需要将小数作取整。</p><p>获取样式</p><p>offsetWidth包含了边框，而clientWidth只包含了内边距和内容不包含外边框，可按需选择<br>但如果想获取元素的其他样式，可用：window.getComputedStyle()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var style = window.getComputedStyle(&quot;元素&quot;, &quot;伪类&quot;);</div><div class="line"></div><div class="line">window.getComputedStyle(obj,false)[attr];</div><div class="line">    </div><div class="line">var h1 = document.querySelector(&quot;h1&quot;);</div><div class="line">window.getComputedStyle(h1,false).width;</div></pre></td></tr></table></figure></p><p>getComputedStyle()和element.style的区别：<br>getComputedStyle()是只读的，不能通过它来修改元素的CSS样式，element.style可以<br>getComputedStyle()可以修改内联，内部和外部样式表的CSS样式，后者只能修改内联样式<br>我们可以把这个属性封装成一个函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function getstyle(obj,attr)&#123;</div><div class="line">    return window.getComputedStyle(obj,false)[attr];</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>然后在动画函数里调用这个函数，在调用的时候传入attr（样式属性），就可以达到适用多种样式变化的目的了~</p><p>使用对象达到同时多运动的效果</p><p>如果我们需要一个元素同时有宽度和高度的变化，就需要多组数据的传入，在这点上讲解的老师使用了JSON的概念：</p><p>设置形参JSON<br>调用时传入{width:100,height:500}，<br>在函数内部用for(var attr in JSON)遍历JSON<br>将所有属性替换为为JSON[attr]<br>但是在我看来这并不是JSON，而是对象：首先，width和height没有加””，这一点就已经不符合JSON的命名要求。再者，for-in循环和object[attr]也适用于对象。但这一点还需验证。</p><p>当添加完多个样式的动画后，用F12会发现，只有一个值达到了调用时设定的目标值，其它的都没有达到。这是因为原本的函数只要判断某一当前值=目标值之后就停止定时器。也就是说假如有3个样式改变，只要有一个样式达到目标值，整个定时器都停了下来。所以这时我们需要为3个运动设立一个统一的动画完成的标志。</p><p>这样，一个适用性较强的动画框架就出来了。<br>最终的动画框架：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">//获取元素的所有属性（包括内联，内部和外部样式表）的函数</div><div class="line">function getStyle(obj,attr)&#123;                </div><div class="line">    if(obj.currentStyle)&#123;</div><div class="line">        return obj.currentStyle[attr];</div><div class="line">    &#125;else&#123;</div><div class="line">        return window.getComputedStyle(obj,false)[attr];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">//通过传参的不同，来达到共用一套函数的效果</div><div class="line">function startmove(obj,keyvalue)&#123; </div><div class="line">    clearInterval(obj.timer); //清除定时器，防止多个定时器同时运行</div><div class="line">    obj.timer = setInterval(function()&#123;</div><div class="line">        var flag = true; //判断每个动画完成的标志</div><div class="line">        for (var attr in keyvalue) &#123;</div><div class="line">            // 1.取值</div><div class="line">            var istyle = 0;</div><div class="line">            if (attr == &quot;opacity&quot;) &#123;</div><div class="line">                //浏览器对浮点数的运算是不准确的，透明度需要作四舍五入</div><div class="line">                istyle = Math.round(parseFloat(getStyle(obj,attr))*100);</div><div class="line">            &#125;else &#123; istyle = parseInt(getStyle(obj,attr));&#125;</div><div class="line">            // 2.计算动画速度</div><div class="line">            var speed = 0;</div><div class="line">            speed = (keyvalue[attr] - istyle)/10;   </div><div class="line">            //缓冲运动，浏览器运行到后期时，speed会出现小数如0.75，</div><div class="line">            // 如果这时div移动到了190，那么这时left值也会出现小数如190.75,</div><div class="line">            // 浏览器默认将小数去掉，宽度为190,下次执行speed还是0.75,</div><div class="line">            // 造成了死循环，div将一直停留在190，到达不了target，定时器一直运行</div><div class="line">            // 如果向左-&gt;速度正值-&gt;向上取整，否则向下取整</div><div class="line">            speed = speed &gt; 0 ? Math.ceil(speed):Math.floor(speed);</div><div class="line">            //3.检测停止</div><div class="line">            if (istyle !== keyvalue[attr]) &#123;</div><div class="line">                flag = false;                   </div><div class="line">            </div><div class="line">                if (attr == &quot;opacity&quot;) &#123; obj.style[attr] = (istyle + speed)/100;&#125;</div><div class="line">                else &#123;obj.style[attr] = istyle + speed + &quot;px&quot;;&#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (flag) &#123;</div><div class="line">            clearInterval(obj.timer);</div><div class="line">        &#125;</div><div class="line">    &#125;,30)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>不足之处：在学习过程中，老师在startmove函数里加入第四个形参fn，并在if(flag)下新增<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if(fn)&#123;</div><div class="line">    fn();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>调用时再传入startmove，可以在startmove完成后再调用startmove，达到诸如宽度改变完再改变高度再改变透明的效果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">startmove(this,&#123;width:400 , height:500&#125;,function()&#123;</div><div class="line">    startmove(this,&#123;opacity:50&#125;);</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><p>但我在实现的过程中浏览器却报错：<br>Failed to execute ‘getComputedStyle’ on ‘Window’: parameter 1 is not of type ‘Element’<br>对于这个错误我不得其解，参数1不是元素？尝试搜索了也无果，这可真有点头疼…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;巩固的知识点&quot;&gt;&lt;a href=&quot;#巩固的知识点&quot; class=&quot;headerlink&quot; title=&quot;巩固的知识点&quot;&gt;&lt;/a&gt;巩固的知识点&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gut
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello world!!</title>
    <link href="http://yoursite.com/2016/03/09/Hello-world-0/"/>
    <id>http://yoursite.com/2016/03/09/Hello-world-0/</id>
    <published>2016-03-09T15:16:03.000Z</published>
    <updated>2017-09-28T16:17:55.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="hexo和随想"><a href="#hexo和随想" class="headerlink" title="hexo和随想"></a>hexo和随想</h2><p>经历了一个下午+一个晚上的折腾，终于顺利地搭建好基于hexo，托管在Github上的这个博客。这其中踩过的坑可着实不少啊…诸如 https/Github的.git 隐藏文件/hexo3的插件/ssh 等等等等。甚至在写这篇文章的时候我都不知道到底能否顺利的发出去。 但是一天之内接触并学到如此多新鲜知识，也是挺有满足感的。</p><p>虽然剧情也算峰回路转，最终还是顺利呈现了。但是却发觉自己在部署时一次次遇到 Error 的时候的那种烦躁心情,跟调试 bug 时，跟周边的人讲话却对牛弹琴时的那种烦躁感，简直如出一辙。什么时候开始，自己也变得这么焦虑了呢？我想自己心里是有底的。其实不止这种焦虑，当下所有的矛头全都需由手上专注的东西来解决，有这么一个简单的路径，自己应该也算是幸福的吧。毕竟世事并非都有这么一条 “万事俱备，只欠东风” 的简单路径。</p><p>但又是不是所有人都喜欢简单呢？在商场/政坛呼风唤雨的 “木下总统” 们，在乡里争着一亩三分地的男女老少，是否又希望自己的人生的十字路口都有一个明确的向导，希望自己的路越直越好？我想，对于他们来说，也许呼风唤雨，也许争三分地，就是自己人生里必经的一环，人生大路上必须碰见的向导吧。而我所希望的，大抵也是他们心中 “走向未知” 的危险做法。</p><p>这个时候的我，是一个懂HTML/CSS皮毛，正在学习Javascript的前端菜鸟，不过我想既然要走下去，就要一鼓作气持之以恒，成功部署这个博客，也算是给自己打一针强心剂吧。不久之前还依然在问自己是否真的适合这个职业？我想自己现在应该有答案了。人其实是多面的，我也有很多个面向。如金融/法律/音乐/甚至产品经理…但心中所求，不过是和程序一样简单却又规范的世界。</p><p>对了，最近在看 深夜食堂2 和 纸牌屋4.两种截然不同的风格，都带给我十分愉快的体验。(凯文史派西爆发时候的哭腔让我起了一身鸡皮疙瘩)<br>房间 Room 带给我的震撼也很大：逃出被囚禁的牢笼只是first step，打破牢牢锁住自己心里的牢笼与枷锁才是需要更大勇气的关键。小男孩的演技爆表，让这部剧显得格外动人。</p><p>Just keep calm and go on.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;hexo和随想&quot;&gt;&lt;a href=&quot;#hexo和随想&quot; class=&quot;headerlink&quot; title=&quot;hexo和随想&quot;&gt;&lt;/a&gt;hexo和随想&lt;/h2&gt;&lt;p&gt;经历了一个下午+一个晚上的折腾，终于顺利地搭建好基于hexo，托管在Github上的这个博客。这其中
      
    
    </summary>
    
    
  </entry>
  
</feed>
